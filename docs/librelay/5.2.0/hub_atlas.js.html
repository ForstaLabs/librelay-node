<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>hub/atlas.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="AtlasClient.html">AtlasClient</a><ul class='methods'><li data-type='method'><a href="AtlasClient.html#.authenticateViaCode">authenticateViaCode</a></li><li data-type='method'><a href="AtlasClient.html#.authenticateViaPassword">authenticateViaPassword</a></li><li data-type='method'><a href="AtlasClient.html#.authenticateViaPasswordOtp">authenticateViaPasswordOtp</a></li><li data-type='method'><a href="AtlasClient.html#.authenticateViaToken">authenticateViaToken</a></li><li data-type='method'><a href="AtlasClient.html#.factory">factory</a></li><li data-type='method'><a href="AtlasClient.html#.requestAuthentication">requestAuthentication</a></li><li data-type='method'><a href="AtlasClient.html#fetch">fetch</a></li><li data-type='method'><a href="AtlasClient.html#getDevices">getDevices</a></li><li data-type='method'><a href="AtlasClient.html#getUsers">getUsers</a></li><li data-type='method'><a href="AtlasClient.html#maintainJWT">maintainJWT</a></li><li data-type='method'><a href="AtlasClient.html#resolveTags">resolveTags</a></li><li data-type='method'><a href="AtlasClient.html#resolveTagsBatch">resolveTagsBatch</a></li></ul></li><li><a href="Attachment.html">Attachment</a><ul class='methods'><li data-type='method'><a href="Attachment.html#.fromFile">fromFile</a></li></ul></li><li><a href="MessageReceiver.html">MessageReceiver</a><ul class='methods'><li data-type='method'><a href="MessageReceiver.html#.factory">factory</a></li><li data-type='method'><a href="MessageReceiver.html#addEventListener">addEventListener</a></li><li data-type='method'><a href="MessageReceiver.html#close">close</a></li><li data-type='method'><a href="MessageReceiver.html#connect">connect</a></li><li data-type='method'><a href="MessageReceiver.html#drain">drain</a></li><li data-type='method'><a href="MessageReceiver.html#removeEventListener">removeEventListener</a></li></ul></li><li><a href="MessageSender.html">MessageSender</a><ul class='methods'><li data-type='method'><a href="MessageSender.html#.factory">factory</a></li><li data-type='method'><a href="MessageSender.html#send">send</a></li></ul></li><li><a href="module-errors-NetworkError.html">NetworkError</a></li><li><a href="module-errors-ProtocolError.html">ProtocolError</a></li><li><a href="module-errors-RelayError.html">RelayError</a></li><li><a href="module-errors-UnregisteredUserError.html">UnregisteredUserError</a></li><li><a href="module-eventing-Event.html">Event</a></li><li><a href="module-eventing-EventTarget.html">EventTarget</a><ul class='methods'><li data-type='method'><a href="module-eventing-EventTarget.html#addEventListener">addEventListener</a></li><li data-type='method'><a href="module-eventing-EventTarget.html#removeEventListener">removeEventListener</a></li></ul></li><li><a href="module-eventing-KeyChangeEvent.html">KeyChangeEvent</a></li><li><a href="module-exchange-Exchange.html">Exchange</a><ul class='methods'><li data-type='method'><a href="module-exchange-Exchange.html#addMessageListener">addMessageListener</a></li><li data-type='method'><a href="module-exchange-Exchange.html#decodePayload">decodePayload</a></li><li data-type='method'><a href="module-exchange-Exchange.html#encodePayload">encodePayload</a></li><li data-type='method'><a href="module-exchange-Exchange.html#getAttachments">getAttachments</a></li><li data-type='method'><a href="module-exchange-Exchange.html#getBody">getBody</a></li><li data-type='method'><a href="module-exchange-Exchange.html#getDataProperty">getDataProperty</a></li><li data-type='method'><a href="module-exchange-Exchange.html#getExpiration">getExpiration</a></li><li data-type='method'><a href="module-exchange-Exchange.html#getFlags">getFlags</a></li><li data-type='method'><a href="module-exchange-Exchange.html#getMessageId">getMessageId</a></li><li data-type='method'><a href="module-exchange-Exchange.html#getMessageRef">getMessageRef</a></li><li data-type='method'><a href="module-exchange-Exchange.html#getMessageType">getMessageType</a></li><li data-type='method'><a href="module-exchange-Exchange.html#getSender">getSender</a></li><li data-type='method'><a href="module-exchange-Exchange.html#getSource">getSource</a></li><li data-type='method'><a href="module-exchange-Exchange.html#getSourceDevice">getSourceDevice</a></li><li data-type='method'><a href="module-exchange-Exchange.html#getThreadExpression">getThreadExpression</a></li><li data-type='method'><a href="module-exchange-Exchange.html#getThreadId">getThreadId</a></li><li data-type='method'><a href="module-exchange-Exchange.html#getThreadTitle">getThreadTitle</a></li><li data-type='method'><a href="module-exchange-Exchange.html#getThreadType">getThreadType</a></li><li data-type='method'><a href="module-exchange-Exchange.html#getTimestamp">getTimestamp</a></li><li data-type='method'><a href="module-exchange-Exchange.html#getUserAgent">getUserAgent</a></li><li data-type='method'><a href="module-exchange-Exchange.html#recvMessages">recvMessages</a></li><li data-type='method'><a href="module-exchange-Exchange.html#removeMessageListener">removeMessageListener</a></li><li data-type='method'><a href="module-exchange-Exchange.html#send">send</a></li><li data-type='method'><a href="module-exchange-Exchange.html#setAttachments">setAttachments</a></li><li data-type='method'><a href="module-exchange-Exchange.html#setBody">setBody</a></li><li data-type='method'><a href="module-exchange-Exchange.html#setDataProperty">setDataProperty</a></li><li data-type='method'><a href="module-exchange-Exchange.html#setExpiration">setExpiration</a></li><li data-type='method'><a href="module-exchange-Exchange.html#setFlags">setFlags</a></li><li data-type='method'><a href="module-exchange-Exchange.html#setMessageId">setMessageId</a></li><li data-type='method'><a href="module-exchange-Exchange.html#setMessageRef">setMessageRef</a></li><li data-type='method'><a href="module-exchange-Exchange.html#setMessageType">setMessageType</a></li><li data-type='method'><a href="module-exchange-Exchange.html#setSender">setSender</a></li><li data-type='method'><a href="module-exchange-Exchange.html#setSource">setSource</a></li><li data-type='method'><a href="module-exchange-Exchange.html#setSourceDevice">setSourceDevice</a></li><li data-type='method'><a href="module-exchange-Exchange.html#setThreadExpression">setThreadExpression</a></li><li data-type='method'><a href="module-exchange-Exchange.html#setThreadId">setThreadId</a></li><li data-type='method'><a href="module-exchange-Exchange.html#setThreadTitle">setThreadTitle</a></li><li data-type='method'><a href="module-exchange-Exchange.html#setThreadType">setThreadType</a></li><li data-type='method'><a href="module-exchange-Exchange.html#setTimestamp">setTimestamp</a></li><li data-type='method'><a href="module-exchange-Exchange.html#setUserAgent">setUserAgent</a></li></ul></li><li><a href="module-exchange-ExchangeV1.html">ExchangeV1</a><ul class='methods'><li data-type='method'><a href="module-exchange-ExchangeV1.html#addMessageListener">addMessageListener</a></li><li data-type='method'><a href="module-exchange-ExchangeV1.html#decodePayload">decodePayload</a></li><li data-type='method'><a href="module-exchange-ExchangeV1.html#encodePayload">encodePayload</a></li><li data-type='method'><a href="module-exchange-ExchangeV1.html#getAttachments">getAttachments</a></li><li data-type='method'><a href="module-exchange-ExchangeV1.html#getBody">getBody</a></li><li data-type='method'><a href="module-exchange-ExchangeV1.html#getDataProperty">getDataProperty</a></li><li data-type='method'><a href="module-exchange-ExchangeV1.html#getExpiration">getExpiration</a></li><li data-type='method'><a href="module-exchange-ExchangeV1.html#getFlags">getFlags</a></li><li data-type='method'><a href="module-exchange-ExchangeV1.html#getMessageId">getMessageId</a></li><li data-type='method'><a href="module-exchange-ExchangeV1.html#getMessageRef">getMessageRef</a></li><li data-type='method'><a href="module-exchange-ExchangeV1.html#getMessageType">getMessageType</a></li><li data-type='method'><a href="module-exchange-ExchangeV1.html#getSender">getSender</a></li><li data-type='method'><a href="module-exchange-ExchangeV1.html#getSource">getSource</a></li><li data-type='method'><a href="module-exchange-ExchangeV1.html#getSourceDevice">getSourceDevice</a></li><li data-type='method'><a href="module-exchange-ExchangeV1.html#getThreadExpression">getThreadExpression</a></li><li data-type='method'><a href="module-exchange-ExchangeV1.html#getThreadId">getThreadId</a></li><li data-type='method'><a href="module-exchange-ExchangeV1.html#getThreadTitle">getThreadTitle</a></li><li data-type='method'><a href="module-exchange-ExchangeV1.html#getThreadType">getThreadType</a></li><li data-type='method'><a href="module-exchange-ExchangeV1.html#getTimestamp">getTimestamp</a></li><li data-type='method'><a href="module-exchange-ExchangeV1.html#getUserAgent">getUserAgent</a></li><li data-type='method'><a href="module-exchange-ExchangeV1.html#recvMessages">recvMessages</a></li><li data-type='method'><a href="module-exchange-ExchangeV1.html#removeMessageListener">removeMessageListener</a></li><li data-type='method'><a href="module-exchange-ExchangeV1.html#send">send</a></li><li data-type='method'><a href="module-exchange-ExchangeV1.html#setAttachments">setAttachments</a></li><li data-type='method'><a href="module-exchange-ExchangeV1.html#setBody">setBody</a></li><li data-type='method'><a href="module-exchange-ExchangeV1.html#setDataProperty">setDataProperty</a></li><li data-type='method'><a href="module-exchange-ExchangeV1.html#setExpiration">setExpiration</a></li><li data-type='method'><a href="module-exchange-ExchangeV1.html#setFlags">setFlags</a></li><li data-type='method'><a href="module-exchange-ExchangeV1.html#setMessageId">setMessageId</a></li><li data-type='method'><a href="module-exchange-ExchangeV1.html#setMessageRef">setMessageRef</a></li><li data-type='method'><a href="module-exchange-ExchangeV1.html#setMessageType">setMessageType</a></li><li data-type='method'><a href="module-exchange-ExchangeV1.html#setSender">setSender</a></li><li data-type='method'><a href="module-exchange-ExchangeV1.html#setSource">setSource</a></li><li data-type='method'><a href="module-exchange-ExchangeV1.html#setSourceDevice">setSourceDevice</a></li><li data-type='method'><a href="module-exchange-ExchangeV1.html#setThreadExpression">setThreadExpression</a></li><li data-type='method'><a href="module-exchange-ExchangeV1.html#setThreadId">setThreadId</a></li><li data-type='method'><a href="module-exchange-ExchangeV1.html#setThreadTitle">setThreadTitle</a></li><li data-type='method'><a href="module-exchange-ExchangeV1.html#setThreadType">setThreadType</a></li><li data-type='method'><a href="module-exchange-ExchangeV1.html#setTimestamp">setTimestamp</a></li><li data-type='method'><a href="module-exchange-ExchangeV1.html#setUserAgent">setUserAgent</a></li></ul></li><li><a href="OutgoingMessage.html">OutgoingMessage</a></li><li><a href="SignalClient.html">SignalClient</a><ul class='methods'><li data-type='method'><a href="SignalClient.html#.factory">factory</a></li></ul></li><li><a href="util.html">util</a></li></ul><h3>Modules</h3><ul><li><a href="module-backing.html">backing</a></li><li><a href="module-errors.html">errors</a></li><li><a href="module-eventing.html">eventing</a><ul class='methods'><li data-type='method'><a href="module-eventing.html#~accept">accept</a></li></ul></li><li><a href="module-exchange.html">exchange</a><ul class='methods'><li data-type='method'><a href="module-exchange.html#.create">create</a></li><li data-type='method'><a href="module-exchange.html#.decode">decode</a></li></ul></li><li><a href="module-util.html">util</a><ul class='methods'><li data-type='method'><a href="module-util.html#~consoleInput">consoleInput</a></li><li data-type='method'><a href="module-util.html#~never">never</a></li><li data-type='method'><a href="module-util.html#~sleep">sleep</a></li></ul></li></ul><h3>Events</h3><ul><li><a href="MessageReceiver.html#event:error">error</a></li><li><a href="MessageReceiver.html#event:keychange">keychange</a></li><li><a href="MessageReceiver.html#event:message">message</a></li><li><a href="MessageReceiver.html#event:receipt">receipt</a></li><li><a href="MessageReceiver.html#event:sent">sent</a></li><li><a href="MessageSender.html#event:error">error</a></li><li><a href="MessageSender.html#event:keychange">keychange</a></li></ul><h3>Global</h3><ul><li><a href="global.html#registerAccount">registerAccount</a></li><li><a href="global.html#registerDevice">registerDevice</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">hub/atlas.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>// vim: ts=4:sw=4:expandtab

const errors = require('../errors');
const fetch = require('./fetch');
const storage = require('../storage');
const util = require('../util');

const defaultUrl = 'https://atlas.forsta.io';
const credStoreKey = 'atlasCredential';
const urlStoreKey = 'atlasUrl';


function atobJWT(str) {
    /* See: https://github.com/yourkarma/JWT/issues/8 */
    return Buffer.from(str.replace(/_/g, '/').replace(/-/g, '+'), 'base64').toString('binary');
}

function decodeJWT(encoded_token) {
    let token;
    try {
        const parts = encoded_token.split('.').map(atobJWT);
        token = {
            header: JSON.parse(parts[0]),
            payload: JSON.parse(parts[1]),
            secret: parts[2]
        };
    } catch(e) {
        throw new Error('Invalid Token');
    }
    if (!token.payload || !token.payload.exp) {
        throw TypeError("Invalid Token");
    }
    if (token.payload.exp * 1000 &lt;= Date.now()) {
        throw Error("Expired Token");
    }
    return token;
}


/**
 * A tag is of the form, "@label:org".  They can be used for describing users or groups.
 *
 * @typedef {string} Tag
 */

/**
 * Response from an authentication request indicating the type
 * of auth challenge required to complete.
 *
 * @typedef {Object} AuthenticationRequestChallenge
 * @property {string} type - The authentication type.  E.g. "password", "totp", etc..
 * @property {function} authenticate - Handler function to be called with challenge response.
 */

/**
 * Tag expression are informal arrangement of {@link Tag}s using set operators like
 * "-" (minus) "+" (plus).  Paranthesis can be used to create logical groups too.
 * For example "@joe + @brunchgroup" would respresent all users in the @brunchgroup
 * as well as @joe (assuming he was not already in @brunchgroup).  You can exclude
 * specific users with "-", ie. "@brunchgroup - @cindy" or even,
 * "@brunchgroup - (@joe + @cindy)".
 *
 * @typedef {string} TagExpression
 */

/**
 * A resolved tag expression is the computed set of data for a given {@link TagExpression}.
 * It represents a snapshot of the current state of membership for a tag expression.
 * The values can be cached for short periods but should avoid being stored perminantly
 * as membership changes can occur behind the scenes.
 *
 * @typedef {Object} ResolvedTagExpression
 * @property {string[]} userids - Array of UUIDs belonging to this tag expression.
 * @property {string} universal - The universal (stable) representation of this tag expression
 *                                This value should be used when managing Thread.expression
 *                                values.
 * @property {string[]} tagsIncluded - A list of tag UUIDs which are positively mentioned and
 *                                     as such have affected the final membership.
 * @property {string[]} tagsExcluded - A list of tag UUIDs which are negatively mentioned and
 *                                     as such are NOT in the final membership.
 */

/**
 * @class
 */
class AtlasClient {

    constructor({url=defaultUrl, jwt=null}) {
        this.url = url;
        if (jwt) {
            this.setJWT(jwt);
        }
    }

    setJWT(jwt) {
        const jwtDict = decodeJWT(jwt);
        this.userId = jwtDict.payload.user_id;
        this.orgId = jwtDict.payload.org_id;
        this.authHeader = `JWT ${jwt}`;
    }

    /**
     * Produce a default instance.
     * @returns {AtlasClient}
     */
    static async factory() {
        const url = await storage.getState(urlStoreKey);
        const jwt = await storage.getState(credStoreKey);
        return new this({url, jwt});
    }

    /**
     * Begin authentication process with Atlas server.
     *
     * @param {Tag} userTag
     * @param {Object} [options] - Options to be fed to {@link 
     * @returns {AuthenticationRequestChallenge}
     */
    static async requestAuthentication(userTag, options) {
        const client = new this(options || {});
        const [user, org] = client.parseTag(userTag);
        try {
            await client.fetch(`/v1/login/send/${org}/${user}/`);
        } catch(e) {
            if (e.code === 409) {
                if (e.response.non_field_errors.includes('totp auth required')) {
                    return {
                        type: "totp",
                        authenticate: (pw, otp) => this.authenticateViaPasswordOtp(userTag, pw, otp, options)
                    };
                } else {
                    return {
                        type: "password",
                        authenticate: pw => this.authenticateViaPassword(userTag, pw, options)
                    };
                }
            }
            throw e;
        }
        return {
            type: "sms",
            authenticate: code => this.authenticateViaCode(userTag, code, options)
        };
    }

    static async requestAuthenticationCode(userTag, options) {
        // DEPRECATED: Use `requestAuthentication` instead.
        const client = new this(options || {});
        const [user, org] = client.parseTag(userTag);
        await client.fetch(`/v1/login/send/${org}/${user}/`);
        return smsCode => this.authenticateViaCode(userTag, smsCode, options);
    }

    /**
     * Authentication challenge response for SMS-code based users.  You probably don't need to call
     * this method directly as it will be associated with
     * {@link AuthenticationRequestChallenge.authenticate} in most cases.
     *
     * @param {Tag} userTag
     * @param {string} code - The 6 digit SMS code you received
     * @param {Object} [options] - Constructor options for {@link AtlasClient}
     * @returns {AtlasClient}
     */
    static async authenticateViaCode(userTag, code, options) {
        const client = new this(options || {});
        const [user, org] = client.parseTag(userTag);
        const authtoken = `${org}:${user}:${code}`;
        await client.authenticate({authtoken});
        return client;
    }

    /**
     * Authentication challenge response for API token users.   Typically used by bots.
     *
     * @param {string} userauthtoken - The secret auth token for this user.
     * @param {Object} [options] - Constructor options for {@link AtlasClient}
     * @returns {AtlasClient}
     */
    static async authenticateViaToken(userauthtoken, options) {
        const client = new this(options || {});
        await client.authenticate({userauthtoken});
        return client;
    }

    /**
     * Authentication challenge response for password based users.  You probably don't need to call
     * this method directly as it will be associated with
     * {@link AuthenticationRequestChallenge.authenticate} in most cases.
     *
     * @param {Tag} userTag
     * @param {string} password
     * @param {Object} [options] - Constructor options for {@link AtlasClient}
     * @returns {AtlasClient}
     */
    static async authenticateViaPassword(fq_tag, password, options) {
        const client = new this(options || {});
        await client.authenticate({fq_tag, password});
        return client;
    }

    /**
     * Authentication challenge response for password+otp (two-factor auth) based users.
     * You probably don't need to call this method directly as it will be associated with
     * {@link AuthenticationRequestChallenge.authenticate} in most cases.
     *
     * @param {Tag} userTag
     * @param {string} password
     * @param {string} otp - 2FA code
     * @param {Object} [options] - Constructor options for {@link AtlasClient}
     * @returns {AtlasClient}
     */
    static async authenticateViaPasswordOtp(fq_tag, password, otp, options) {
        const client = new this(options || {});
        await client.authenticate({fq_tag, password, otp});
        return client;
    }

    async authenticate(creds) {
        /* Creds should be an object of these supported forms..
         * 1. Password auth:
         *    {
         *      fq_tag: "@foo:bar",
         *      password: "secret"
         *    }
         * 1.5 Password+TOTP auth:
         *    {
         *      fq_tag: "@foo:bar",
         *      password: "secret"
         *      otp: "code"
         *    }
         * 2. SMS auth: {
         *      authtoken: "123456",
         *    }
         * 3. Token auth: {
         *      userauthtoken: "APITOKEN",
         *    }
         */
        const auth = await this.fetch('/v1/login/', {
            method: 'POST',
            json: creds
        });
        this.setJWT(auth.token);
        await storage.putState(credStoreKey, auth.token);
        await storage.putState(urlStoreKey, this.url);
    }

    parseTag(tag) {
        tag = tag.replace(/^@/, '');
        const index = tag.indexOf(':');
        if (index === -1) {
            return [tag, 'forsta'];
        } else {
            return [tag.substring(0, index), tag.substring(index + 1)];
        }
    }

    /**
     * Perform an authenticated HTTP fetch to the Atlas service.
     *
     * @param {string} urn - The URN of the resource being requested.
     * @param {Object} [options] - Standard fetch options.
     * @returns {Object} - The response object (decoded JSON).
     */
    async fetch(urn, options) {
        options = options || {};
        options.headers = options.headers || new fetch.Headers();
        if (this.authHeader) {
            options.headers.set('Authorization', this.authHeader);
        }
        const url = [this.url, urn.replace(/^\//, '')].join('/');
        const resp = await fetch(url, options);
        const text = await resp.text();
        let respContent;
        if ((resp.headers.get('content-type') || '').startsWith('application/json') &amp;&amp; text.trim()) {
            respContent = JSON.parse(text);
        } else {
            respContent = text;
        }
        if (!resp.ok) {
            const e = new errors.ProtocolError(resp.status, respContent);
            e.message = `${urn} (${text})`;
            throw e;
        }
        return respContent;
    }

    /**
     * A background task that will keep a sessions JWT fresh.
     *
     * @param {boolean} forceRefresh - Perform an immediate refresh.
     * @param {function} authenticator - Auth handler used for doing JWT refresh.
     * @param {function} [onRefresh] - Callback fired when refresh takes place.
     */
    async maintainJWT(forceRefresh, authenticator, onRefresh) {
        /* Manage auth token expiration.  This routine will reschedule itself as needed. */
        let token = decodeJWT(await storage.getState(credStoreKey));
        const refreshDelay = t => (t.payload.exp - (Date.now() / 1000)) / 2;
        if (forceRefresh || refreshDelay(token) &lt; 1) {
            const encodedToken = await storage.getState(credStoreKey);
            const resp = await this.fetch('/v1/api-token-refresh/', {
                method: 'POST',
                json: {token: encodedToken}
            });
            let jwt;
            if (!resp || !resp.token) {
                if (authenticator) {
                    const result = await authenticator();
                    console.info("Reauthenticated user in maintainJWT");
                    jwt = result.jwt;
                } else {
                    throw new TypeError("Unable to reauthenticate in maintainJWT");
                }
            } else {
                jwt = resp.token;
            }
            token = decodeJWT(jwt);
            console.info("Refreshed JWT in maintainJWT");
            await storage.putState(credStoreKey, jwt);
            this.authHeader = `JWT ${jwt}`;
            this.userId = token.payload.user_id;
            if (onRefresh) {
                try {
                    await onRefresh(token);
                } catch(e) {
                    console.error('onRefresh callback error:', e);
                }
            }
        }
        const nextUpdate = refreshDelay(token);
        console.info('maintainJWT will recheck auth token in ' + nextUpdate + ' seconds');
        util.sleep(nextUpdate).then(this.maintainJWT.bind(this, false, authenticator, onRefresh));
    }

    /**
     * Take a tag expression (i.e "@foo + @bar - (@joe + @sarah)") and parse it into the
     * current user membership.
     *
     * @param {TagExpression} expression 
     * @returns {ResolvedTagExpression}
     */
    async resolveTags(expression) {
        return (await this.resolveTagsBatch([expression]))[0];
    }

    /**
     * Like {@link resolveTags} but performs a batched fetch with an array
     * of expressions.  The results are in the same order as the input array
     * and invalid response will be set to undefined.
     *
     * @param {TagExpression[]} expression
     * @returns {ResolvedTagExpression[]}
     */
    async resolveTagsBatch(expressions) {
        if (!expressions.length) {
            return [];
        }
        const resp = await this.fetch('/v1/tagmath/', {
            method: 'POST',
            json: {expressions}
        });
        /* Enhance the warnings a bit. */
        for (let i = 0; i &lt; resp.results.length; i++) {
            const res = resp.results[i];
            const expr = expressions[i];
            for (const w of res.warnings) {
                w.context = expr.substr(w.position, w.length);
            }
        }
        return resp.results;
    }

    sanitizeTags(expression) {
        /* Clean up tags a bit. Add @ where needed.
         * NOTE: This does not currently support universal format! */
        const tagSplitRe = /([\s()^&amp;+-]+)/;
        const tags = [];
        for (let tag of expression.trim().split(tagSplitRe)) {
            if (!tag) {
                continue;
            } else if (tag.match(/^[a-zA-Z]/)) {
                tag = '@' + tag;
            }
            tags.push(tag);
        }
        return tags.join(' ');
    }

    /**
     * Get user objects based on a list of user IDs.
     *
     * @param {string[]} userIds - Array of user UUIDs to lookup.
     * @param {boolean} [onlyDir] - Only use the Forsta public directory. E.g. only
     *                              return lightweight user objects.
     * @returns {Object[]} User objects.
     */
    async getUsers(userIds, onlyDir) {
        const missing = new Set(userIds);
        const users = [];
        if (!onlyDir) {
            const resp = await this.fetch('/v1/user/?id_in=' + userIds.join());
            for (const user of resp.results) {
                users.push(user);
                missing.delete(user.id);
            }
        }
        if (missing.size) {
            const resp = await this.fetch('/v1/directory/user/?id_in=' +
                                          Array.from(missing).join());
            for (const user of resp.results) {
                users.push(user);
            }
        }
        return users;
    }

    /**
     *The current set of known devices for your account.
     *
     * @returns {Object[]} Device info objects.
     */
    async getDevices() {
        try {
            return (await this.fetch('/v1/provision/account')).devices;
        } catch(e) {
            if (e instanceof errors.ProtocolError &amp;&amp; e.code === 404) {
                return [];
            } else {
                throw e;
            }
        }
    }
}

module.exports = AtlasClient;
</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>

<link type="text/css" rel="stylesheet" href="../../css/jsdoc-overrides.css"/>
