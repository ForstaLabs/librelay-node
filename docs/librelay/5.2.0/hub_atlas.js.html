<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: hub/atlas.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: hub/atlas.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>// vim: ts=4:sw=4:expandtab

const errors = require('../errors');
const fetch = require('./fetch');
const storage = require('../storage');
const util = require('../util');

const defaultUrl = 'https://atlas.forsta.io';
const credStoreKey = 'atlasCredential';
const urlStoreKey = 'atlasUrl';


function atobJWT(str) {
    /* See: https://github.com/yourkarma/JWT/issues/8 */
    return Buffer.from(str.replace(/_/g, '/').replace(/-/g, '+'), 'base64').toString('binary');
}

function decodeJWT(encoded_token) {
    let token;
    try {
        const parts = encoded_token.split('.').map(atobJWT);
        token = {
            header: JSON.parse(parts[0]),
            payload: JSON.parse(parts[1]),
            secret: parts[2]
        };
    } catch(e) {
        throw new Error('Invalid Token');
    }
    if (!token.payload || !token.payload.exp) {
        throw TypeError("Invalid Token");
    }
    if (token.payload.exp * 1000 &lt;= Date.now()) {
        throw Error("Expired Token");
    }
    return token;
}


/**
 * @class
 */
class AtlasClient {

    constructor({url=defaultUrl, jwt=null}) {
        this.url = url;
        if (jwt) {
            this.setJWT(jwt);
        }
    }

    setJWT(jwt) {
        const jwtDict = decodeJWT(jwt);
        this.userId = jwtDict.payload.user_id;
        this.orgId = jwtDict.payload.org_id;
        this.authHeader = `JWT ${jwt}`;
    }

    /**
     * Produce a default instance.
     * @returns {AtlasClient}
     */
    static async factory() {
        const url = await storage.getState(urlStoreKey);
        const jwt = await storage.getState(credStoreKey);
        return new this({url, jwt});
    }

    static async requestAuthentication(userTag, options) {
        const client = new this(options || {});
        const [user, org] = client.parseTag(userTag);
        try {
            await client.fetch(`/v1/login/send/${org}/${user}/`);
        } catch(e) {
            if (e.code === 409) {
                if (e.response.non_field_errors.includes('totp auth required')) {
                    return {
                        type: "totp",
                        authenticate: (pw, otp) => this.authenticateViaPasswordOtp(userTag, pw, otp, options)
                    };
                } else {
                    return {
                        type: "password",
                        authenticate: pw => this.authenticateViaPassword(userTag, pw, options)
                    };
                }
            }
            throw e;
        }
        return {
            type: "sms",
            authenticate: code => this.authenticateViaCode(userTag, code, options)
        };
    }

    static async requestAuthenticationCode(userTag, options) {
        // DEPRECATED: Use `requestAuthentication` instead.
        const client = new this(options || {});
        const [user, org] = client.parseTag(userTag);
        await client.fetch(`/v1/login/send/${org}/${user}/`);
        return smsCode => this.authenticateViaCode(userTag, smsCode, options);
    }

    static async authenticateViaCode(userTag, code, options) {
        const client = new this(options || {});
        const [user, org] = client.parseTag(userTag);
        const authtoken = `${org}:${user}:${code}`;
        await client.authenticate({authtoken});
        return client;
    }

    static async authenticateViaToken(userauthtoken, options) {
        const client = new this(options || {});
        await client.authenticate({userauthtoken});
        return client;
    }

    static async authenticateViaPassword(fq_tag, password, options) {
        const client = new this(options || {});
        await client.authenticate({fq_tag, password});
        return client;
    }

    static async authenticateViaPasswordOtp(fq_tag, password, otp, options) {
        const client = new this(options || {});
        await client.authenticate({fq_tag, password, otp});
        return client;
    }


    async authenticate(creds) {
        /* Creds should be an object of these supported forms..
         * 1. Password auth:
         *    {
         *      fq_tag: "@foo:bar",
         *      password: "secret"
         *    }
         * 1.5 Password+TOTP auth:
         *    {
         *      fq_tag: "@foo:bar",
         *      password: "secret"
         *      otp: "code"
         *    }
         * 2. SMS auth: {
         *      authtoken: "123456",
         *    }
         * 3. Token auth: {
         *      userauthtoken: "APITOKEN",
         *    }
         */
        const auth = await this.fetch('/v1/login/', {
            method: 'POST',
            json: creds
        });
        this.setJWT(auth.token);
        await storage.putState(credStoreKey, auth.token);
        await storage.putState(urlStoreKey, this.url);
    }

    parseTag(tag) {
        tag = tag.replace(/^@/, '');
        const index = tag.indexOf(':');
        if (index === -1) {
            return [tag, 'forsta'];
        } else {
            return [tag.substring(0, index), tag.substring(index + 1)];
        }
    }

    async fetch(urn, options) {
        options = options || {};
        options.headers = options.headers || new fetch.Headers();
        if (this.authHeader) {
            options.headers.set('Authorization', this.authHeader);
        }
        const url = [this.url, urn.replace(/^\//, '')].join('/');
        const resp = await fetch(url, options);
        const text = await resp.text();
        let respContent;
        if ((resp.headers.get('content-type') || '').startsWith('application/json') &amp;&amp; text.trim()) {
            respContent = JSON.parse(text);
        } else {
            respContent = text;
        }
        if (!resp.ok) {
            const e = new errors.ProtocolError(resp.status, respContent);
            e.message = `${urn} (${text})`;
            throw e;
        }
        return respContent;
    }

    async maintainJWT(forceRefresh, authenticator, onRefresh) {
        /* Manage auth token expiration.  This routine will reschedule itself as needed. */
        let token = decodeJWT(await storage.getState(credStoreKey));
        const refreshDelay = t => (t.payload.exp - (Date.now() / 1000)) / 2;
        if (forceRefresh || refreshDelay(token) &lt; 1) {
            const encodedToken = await storage.getState(credStoreKey);
            const resp = await this.fetch('/v1/api-token-refresh/', {
                method: 'POST',
                json: {token: encodedToken}
            });
            let jwt;
            if (!resp || !resp.token) {
                if (authenticator) {
                    const result = await authenticator();
                    console.info("Reauthenticated user in maintainJWT");
                    jwt = result.jwt;
                } else {
                    throw new TypeError("Unable to reauthenticate in maintainJWT");
                }
            } else {
                jwt = resp.token;
            }
            token = decodeJWT(jwt);
            console.info("Refreshed JWT in maintainJWT");
            await storage.putState(credStoreKey, jwt);
            this.authHeader = `JWT ${jwt}`;
            this.userId = token.payload.user_id;
            if (onRefresh) {
                try {
                    await onRefresh(token);
                } catch(e) {
                    console.error('onRefresh callback error:', e);
                }
            }
        }
        const nextUpdate = refreshDelay(token);
        console.info('maintainJWT will recheck auth token in ' + nextUpdate + ' seconds');
        util.sleep(nextUpdate).then(this.maintainJWT.bind(this, false, authenticator, onRefresh));
    }

    async resolveTags(expression) {
        return (await this.resolveTagsBatch([expression]))[0];
    }

    async resolveTagsBatch(expressions) {
        if (!expressions.length) {
            return [];
        }
        const resp = await this.fetch('/v1/tagmath/', {
            method: 'POST',
            json: {expressions}
        });
        /* Enhance the warnings a bit. */
        for (let i = 0; i &lt; resp.results.length; i++) {
            const res = resp.results[i];
            const expr = expressions[i];
            for (const w of res.warnings) {
                w.context = expr.substr(w.position, w.length);
            }
        }
        return resp.results;
    }

    sanitizeTags(expression) {
        /* Clean up tags a bit. Add @ where needed.
         * NOTE: This does not currently support universal format! */
        const tagSplitRe = /([\s()^&amp;+-]+)/;
        const tags = [];
        for (let tag of expression.trim().split(tagSplitRe)) {
            if (!tag) {
                continue;
            } else if (tag.match(/^[a-zA-Z]/)) {
                tag = '@' + tag;
            }
            tags.push(tag);
        }
        return tags.join(' ');
    }

    async getUsers(userIds, onlyDir) {
        const missing = new Set(userIds);
        const users = [];
        if (!onlyDir) {
            const resp = await this.fetch('/v1/user/?id_in=' + userIds.join());
            for (const user of resp.results) {
                users.push(user);
                missing.delete(user.id);
            }
        }
        if (missing.size) {
            const resp = await this.fetch('/v1/directory/user/?id_in=' +
                                          Array.from(missing).join());
            for (const user of resp.results) {
                users.push(user);
            }
        }
        return users;
    }

    async getDevices() {
        try {
            return (await this.fetch('/v1/provision/account')).devices;
        } catch(e) {
            if (e instanceof errors.ProtocolError &amp;&amp; e.code === 404) {
                return [];
            } else {
                throw e;
            }
        }
    }
}

module.exports = AtlasClient;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-backing.html">backing</a></li><li><a href="module-errors.html">errors</a></li><li><a href="module-eventing.html">eventing</a></li><li><a href="module-exchange.html">exchange</a></li><li><a href="module-util.html">util</a></li></ul><h3>Classes</h3><ul><li><a href="AtlasClient.html">AtlasClient</a></li><li><a href="Attachment.html">Attachment</a></li><li><a href="MessageReceiver.html">MessageReceiver</a></li><li><a href="MessageSender.html">MessageSender</a></li><li><a href="module-errors-NetworkError.html">NetworkError</a></li><li><a href="module-errors-ProtocolError.html">ProtocolError</a></li><li><a href="module-errors-RelayError.html">RelayError</a></li><li><a href="module-errors-UnregisteredUserError.html">UnregisteredUserError</a></li><li><a href="module-eventing-Event.html">Event</a></li><li><a href="module-eventing-EventTarget.html">EventTarget</a></li><li><a href="module-eventing-KeyChangeEvent.html">KeyChangeEvent</a></li><li><a href="module-exchange-Exchange.html">Exchange</a></li><li><a href="OutgoingMessage.html">OutgoingMessage</a></li><li><a href="SignalClient.html">SignalClient</a></li><li><a href="util.html">util</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Thu Aug 16 2018 17:08:44 GMT-0600 (MDT)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
