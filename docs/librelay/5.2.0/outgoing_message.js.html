<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>outgoing_message.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="AtlasClient.html">AtlasClient</a><ul class='methods'><li data-type='method'><a href="AtlasClient.html#.authenticateViaCode">authenticateViaCode</a></li><li data-type='method'><a href="AtlasClient.html#.authenticateViaPassword">authenticateViaPassword</a></li><li data-type='method'><a href="AtlasClient.html#.authenticateViaPasswordOtp">authenticateViaPasswordOtp</a></li><li data-type='method'><a href="AtlasClient.html#.authenticateViaToken">authenticateViaToken</a></li><li data-type='method'><a href="AtlasClient.html#.factory">factory</a></li><li data-type='method'><a href="AtlasClient.html#.requestAuthentication">requestAuthentication</a></li><li data-type='method'><a href="AtlasClient.html#fetch">fetch</a></li><li data-type='method'><a href="AtlasClient.html#getDevices">getDevices</a></li><li data-type='method'><a href="AtlasClient.html#getUsers">getUsers</a></li><li data-type='method'><a href="AtlasClient.html#maintainJWT">maintainJWT</a></li><li data-type='method'><a href="AtlasClient.html#resolveTags">resolveTags</a></li><li data-type='method'><a href="AtlasClient.html#resolveTagsBatch">resolveTagsBatch</a></li></ul></li><li><a href="Attachment.html">Attachment</a><ul class='methods'><li data-type='method'><a href="Attachment.html#.fromFile">fromFile</a></li></ul></li><li><a href="MessageReceiver.html">MessageReceiver</a><ul class='methods'><li data-type='method'><a href="MessageReceiver.html#.factory">factory</a></li><li data-type='method'><a href="MessageReceiver.html#addEventListener">addEventListener</a></li><li data-type='method'><a href="MessageReceiver.html#close">close</a></li><li data-type='method'><a href="MessageReceiver.html#connect">connect</a></li><li data-type='method'><a href="MessageReceiver.html#drain">drain</a></li><li data-type='method'><a href="MessageReceiver.html#removeEventListener">removeEventListener</a></li></ul></li><li><a href="MessageSender.html">MessageSender</a><ul class='methods'><li data-type='method'><a href="MessageSender.html#.factory">factory</a></li><li data-type='method'><a href="MessageSender.html#send">send</a></li></ul></li><li><a href="module-errors-NetworkError.html">NetworkError</a></li><li><a href="module-errors-ProtocolError.html">ProtocolError</a></li><li><a href="module-errors-RelayError.html">RelayError</a></li><li><a href="module-errors-UnregisteredUserError.html">UnregisteredUserError</a></li><li><a href="module-eventing-Event.html">Event</a></li><li><a href="module-eventing-EventTarget.html">EventTarget</a><ul class='methods'><li data-type='method'><a href="module-eventing-EventTarget.html#addEventListener">addEventListener</a></li><li data-type='method'><a href="module-eventing-EventTarget.html#removeEventListener">removeEventListener</a></li></ul></li><li><a href="module-eventing-KeyChangeEvent.html">KeyChangeEvent</a></li><li><a href="module-exchange-Exchange.html">Exchange</a><ul class='methods'><li data-type='method'><a href="module-exchange-Exchange.html#addMessageListener">addMessageListener</a></li><li data-type='method'><a href="module-exchange-Exchange.html#decodePayload">decodePayload</a></li><li data-type='method'><a href="module-exchange-Exchange.html#encodePayload">encodePayload</a></li><li data-type='method'><a href="module-exchange-Exchange.html#getAttachments">getAttachments</a></li><li data-type='method'><a href="module-exchange-Exchange.html#getBody">getBody</a></li><li data-type='method'><a href="module-exchange-Exchange.html#getDataProperty">getDataProperty</a></li><li data-type='method'><a href="module-exchange-Exchange.html#getExpiration">getExpiration</a></li><li data-type='method'><a href="module-exchange-Exchange.html#getFlags">getFlags</a></li><li data-type='method'><a href="module-exchange-Exchange.html#getMessageId">getMessageId</a></li><li data-type='method'><a href="module-exchange-Exchange.html#getMessageRef">getMessageRef</a></li><li data-type='method'><a href="module-exchange-Exchange.html#getMessageType">getMessageType</a></li><li data-type='method'><a href="module-exchange-Exchange.html#getSender">getSender</a></li><li data-type='method'><a href="module-exchange-Exchange.html#getSource">getSource</a></li><li data-type='method'><a href="module-exchange-Exchange.html#getSourceDevice">getSourceDevice</a></li><li data-type='method'><a href="module-exchange-Exchange.html#getThreadExpression">getThreadExpression</a></li><li data-type='method'><a href="module-exchange-Exchange.html#getThreadId">getThreadId</a></li><li data-type='method'><a href="module-exchange-Exchange.html#getThreadTitle">getThreadTitle</a></li><li data-type='method'><a href="module-exchange-Exchange.html#getThreadType">getThreadType</a></li><li data-type='method'><a href="module-exchange-Exchange.html#getTimestamp">getTimestamp</a></li><li data-type='method'><a href="module-exchange-Exchange.html#getUserAgent">getUserAgent</a></li><li data-type='method'><a href="module-exchange-Exchange.html#recvMessages">recvMessages</a></li><li data-type='method'><a href="module-exchange-Exchange.html#removeMessageListener">removeMessageListener</a></li><li data-type='method'><a href="module-exchange-Exchange.html#send">send</a></li><li data-type='method'><a href="module-exchange-Exchange.html#setAttachments">setAttachments</a></li><li data-type='method'><a href="module-exchange-Exchange.html#setBody">setBody</a></li><li data-type='method'><a href="module-exchange-Exchange.html#setDataProperty">setDataProperty</a></li><li data-type='method'><a href="module-exchange-Exchange.html#setExpiration">setExpiration</a></li><li data-type='method'><a href="module-exchange-Exchange.html#setFlags">setFlags</a></li><li data-type='method'><a href="module-exchange-Exchange.html#setMessageId">setMessageId</a></li><li data-type='method'><a href="module-exchange-Exchange.html#setMessageRef">setMessageRef</a></li><li data-type='method'><a href="module-exchange-Exchange.html#setMessageType">setMessageType</a></li><li data-type='method'><a href="module-exchange-Exchange.html#setSender">setSender</a></li><li data-type='method'><a href="module-exchange-Exchange.html#setSource">setSource</a></li><li data-type='method'><a href="module-exchange-Exchange.html#setSourceDevice">setSourceDevice</a></li><li data-type='method'><a href="module-exchange-Exchange.html#setThreadExpression">setThreadExpression</a></li><li data-type='method'><a href="module-exchange-Exchange.html#setThreadId">setThreadId</a></li><li data-type='method'><a href="module-exchange-Exchange.html#setThreadTitle">setThreadTitle</a></li><li data-type='method'><a href="module-exchange-Exchange.html#setThreadType">setThreadType</a></li><li data-type='method'><a href="module-exchange-Exchange.html#setTimestamp">setTimestamp</a></li><li data-type='method'><a href="module-exchange-Exchange.html#setUserAgent">setUserAgent</a></li></ul></li><li><a href="module-exchange-ExchangeV1.html">ExchangeV1</a><ul class='methods'><li data-type='method'><a href="module-exchange-ExchangeV1.html#addMessageListener">addMessageListener</a></li><li data-type='method'><a href="module-exchange-ExchangeV1.html#decodePayload">decodePayload</a></li><li data-type='method'><a href="module-exchange-ExchangeV1.html#encodePayload">encodePayload</a></li><li data-type='method'><a href="module-exchange-ExchangeV1.html#getAttachments">getAttachments</a></li><li data-type='method'><a href="module-exchange-ExchangeV1.html#getBody">getBody</a></li><li data-type='method'><a href="module-exchange-ExchangeV1.html#getDataProperty">getDataProperty</a></li><li data-type='method'><a href="module-exchange-ExchangeV1.html#getExpiration">getExpiration</a></li><li data-type='method'><a href="module-exchange-ExchangeV1.html#getFlags">getFlags</a></li><li data-type='method'><a href="module-exchange-ExchangeV1.html#getMessageId">getMessageId</a></li><li data-type='method'><a href="module-exchange-ExchangeV1.html#getMessageRef">getMessageRef</a></li><li data-type='method'><a href="module-exchange-ExchangeV1.html#getMessageType">getMessageType</a></li><li data-type='method'><a href="module-exchange-ExchangeV1.html#getSender">getSender</a></li><li data-type='method'><a href="module-exchange-ExchangeV1.html#getSource">getSource</a></li><li data-type='method'><a href="module-exchange-ExchangeV1.html#getSourceDevice">getSourceDevice</a></li><li data-type='method'><a href="module-exchange-ExchangeV1.html#getThreadExpression">getThreadExpression</a></li><li data-type='method'><a href="module-exchange-ExchangeV1.html#getThreadId">getThreadId</a></li><li data-type='method'><a href="module-exchange-ExchangeV1.html#getThreadTitle">getThreadTitle</a></li><li data-type='method'><a href="module-exchange-ExchangeV1.html#getThreadType">getThreadType</a></li><li data-type='method'><a href="module-exchange-ExchangeV1.html#getTimestamp">getTimestamp</a></li><li data-type='method'><a href="module-exchange-ExchangeV1.html#getUserAgent">getUserAgent</a></li><li data-type='method'><a href="module-exchange-ExchangeV1.html#recvMessages">recvMessages</a></li><li data-type='method'><a href="module-exchange-ExchangeV1.html#removeMessageListener">removeMessageListener</a></li><li data-type='method'><a href="module-exchange-ExchangeV1.html#send">send</a></li><li data-type='method'><a href="module-exchange-ExchangeV1.html#setAttachments">setAttachments</a></li><li data-type='method'><a href="module-exchange-ExchangeV1.html#setBody">setBody</a></li><li data-type='method'><a href="module-exchange-ExchangeV1.html#setDataProperty">setDataProperty</a></li><li data-type='method'><a href="module-exchange-ExchangeV1.html#setExpiration">setExpiration</a></li><li data-type='method'><a href="module-exchange-ExchangeV1.html#setFlags">setFlags</a></li><li data-type='method'><a href="module-exchange-ExchangeV1.html#setMessageId">setMessageId</a></li><li data-type='method'><a href="module-exchange-ExchangeV1.html#setMessageRef">setMessageRef</a></li><li data-type='method'><a href="module-exchange-ExchangeV1.html#setMessageType">setMessageType</a></li><li data-type='method'><a href="module-exchange-ExchangeV1.html#setSender">setSender</a></li><li data-type='method'><a href="module-exchange-ExchangeV1.html#setSource">setSource</a></li><li data-type='method'><a href="module-exchange-ExchangeV1.html#setSourceDevice">setSourceDevice</a></li><li data-type='method'><a href="module-exchange-ExchangeV1.html#setThreadExpression">setThreadExpression</a></li><li data-type='method'><a href="module-exchange-ExchangeV1.html#setThreadId">setThreadId</a></li><li data-type='method'><a href="module-exchange-ExchangeV1.html#setThreadTitle">setThreadTitle</a></li><li data-type='method'><a href="module-exchange-ExchangeV1.html#setThreadType">setThreadType</a></li><li data-type='method'><a href="module-exchange-ExchangeV1.html#setTimestamp">setTimestamp</a></li><li data-type='method'><a href="module-exchange-ExchangeV1.html#setUserAgent">setUserAgent</a></li></ul></li><li><a href="OutgoingMessage.html">OutgoingMessage</a></li><li><a href="SignalClient.html">SignalClient</a><ul class='methods'><li data-type='method'><a href="SignalClient.html#.factory">factory</a></li></ul></li><li><a href="util.html">util</a></li></ul><h3>Modules</h3><ul><li><a href="module-backing.html">backing</a></li><li><a href="module-errors.html">errors</a></li><li><a href="module-eventing.html">eventing</a><ul class='methods'><li data-type='method'><a href="module-eventing.html#~accept">accept</a></li></ul></li><li><a href="module-exchange.html">exchange</a><ul class='methods'><li data-type='method'><a href="module-exchange.html#.create">create</a></li><li data-type='method'><a href="module-exchange.html#.decode">decode</a></li></ul></li><li><a href="module-util.html">util</a><ul class='methods'><li data-type='method'><a href="module-util.html#~consoleInput">consoleInput</a></li><li data-type='method'><a href="module-util.html#~never">never</a></li><li data-type='method'><a href="module-util.html#~sleep">sleep</a></li></ul></li></ul><h3>Events</h3><ul><li><a href="MessageReceiver.html#event:error">error</a></li><li><a href="MessageReceiver.html#event:keychange">keychange</a></li><li><a href="MessageReceiver.html#event:message">message</a></li><li><a href="MessageReceiver.html#event:receipt">receipt</a></li><li><a href="MessageReceiver.html#event:sent">sent</a></li><li><a href="MessageSender.html#event:error">error</a></li><li><a href="MessageSender.html#event:keychange">keychange</a></li></ul><h3>Global</h3><ul><li><a href="global.html#registerAccount">registerAccount</a></li><li><a href="global.html#registerDevice">registerDevice</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">outgoing_message.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>// vim: ts=4:sw=4:expandtab

const errors = require('./errors.js');
const libsignal = require('libsignal');
const protobufs = require('./protobufs');
const storage = require('./storage');
const util = require('./util');


/** @class */
class OutgoingMessage {

    constructor(signal, timestamp, message) {
        this.signal = signal;
        this.timestamp = timestamp;
        this.message = message;
        this.sent = [];
        this.errors = [];
        this.created = Date.now();
        this._listeners = {};
    }

    async getOurAddr() {
        if (this._ourAddr === undefined) {
            this._ourAddr = await storage.getState('addr');
        }
        return this._ourAddr;
    }

    async getOurDeviceId() {
        if (this._ourDeviceId === undefined) {
            this._ourDeviceId = await storage.getState('deviceId');
        }
        return this._ourDeviceId;
    }

    on(event, callback) {
        let handlers = this._listeners[event];
        if (!handlers) {
            handlers = this._listeners[event] = [];
        }
        handlers.push(callback);
    }

    async emit(event) {
        const handlers = this._listeners[event];
        if (!handlers) {
            return;
        }
        const args = Array.from(arguments).slice(1);
        for (const callback of handlers) {
            try {
                await callback.apply(this, args);
            } catch(e) {
                console.error("Event callback error:", e);
            }
        }
    }

    async emitError(addr, reason, error) {
        error.addr = addr;
        error.reason = reason;
        const entry = {
            timestamp: Date.now(),
            error
        };
        this.errors.push(entry);
        await this.emit('error', entry);
    }

    async emitSent(addr) {
        const entry = {
            timestamp: Date.now(),
            addr
        };
        this.sent.push(entry);
        await this.emit('sent', entry);
    }

    async _handleIdentityKeyError(e, options) {
        options = options || {};
        if (!(e instanceof libsignal.UntrustedIdentityKeyError)) {
            throw new TypeError("UntrustedIdentityKeyError required");
        }
        if (!options.forceThrow) {
            await this.emit('keychange', e);
        }
        if (!e.accepted) {
            throw e;
        }
    }

    async getKeysForAddr(addr, updateDevices, reentrant) {
        const _this = this;
        const isSelf = addr === await this.getOurAddr();
        const ourDeviceId = isSelf ? await this.getOurDeviceId() : null;
        async function handleResult(response) {
            await Promise.all(response.devices.map(async device => {
                if (isSelf &amp;&amp; device.deviceId === ourDeviceId) {
                    console.debug("Skipping prekey processing for self");
                    return;
                }
                device.identityKey = response.identityKey;
                const address = new libsignal.ProtocolAddress(addr, device.deviceId);
                const builder = new libsignal.SessionBuilder(storage, address);
                try {
                    await builder.initOutgoing(device);
                } catch(e) {
                    if (e instanceof libsignal.UntrustedIdentityKeyError) {
                        await _this._handleIdentityKeyError(e, {forceThrow: reentrant});
                        await _this.getKeysForAddr(addr, updateDevices, /*reentrant*/ true);
                    } else {
                        throw e;
                    }
                }
            }));
        }
        if (!updateDevices) {
            try {
                await handleResult(await this.signal.getKeysForAddr(addr));
            } catch(e) {
                if (e instanceof errors.ProtocolError &amp;&amp; e.code === 404) {
                    console.warn("Unregistered address (no devices):", addr);
                    await this.removeDeviceIdsForAddr(addr);
                } else {
                    throw e;
                }
            }
        } else {
            await Promise.all(updateDevices.map(async device => {
                try {
                    await handleResult(await _this.signal.getKeysForAddr(addr, device));
                } catch(e) {
                    if (e instanceof errors.ProtocolError &amp;&amp; e.code === 404) {
                        console.warn("Unregistered device:", device);
                        await this.removeDeviceIdsForAddr(addr, [device]);
                    } else {
                        throw e;
                    }
                }
            }));
        }
    }

    async transmitMessage(addr, messages, timestamp) {
        try {
            return await this.signal.sendMessages(addr, messages, timestamp);
        } catch(e) {
            if (e instanceof errors.ProtocolError &amp;&amp; e.code === 404) {
                throw new errors.UnregisteredUserError(addr, e);
            }
            throw e;
        }
    }

    getPaddedMessageLength(messageLength) {
        const messageLengthWithTerminator = messageLength + 1;
        let messagePartCount = Math.floor(messageLengthWithTerminator / 160);
        if (messageLengthWithTerminator % 160 !== 0) {
            messagePartCount++;
        }
        return messagePartCount * 160;
    }

    getPaddedMessageBuffer() {
        let mBuf = protobufs.Content.encode(this.message).finish();
        const padded = new Buffer(this.getPaddedMessageLength(mBuf.byteLength + 1) - 1);
        padded.set(mBuf);
        padded[mBuf.byteLength] = 0x80;
        return padded;
    }

    async _sendToAddr(addr, recurse) {
        const deviceIds = await storage.getDeviceIds(addr);
        const paddedMessage = this.getPaddedMessageBuffer();
        let messages;
        let attempts = 0;
        const ciphers = {};
        do {
            try {
                messages = await Promise.all(deviceIds.map(async id => {
                    const address = new libsignal.ProtocolAddress(addr, id);
                    const sessionCipher = new libsignal.SessionCipher(storage, address);
                    ciphers[address.deviceId] = sessionCipher;
                    return this.toJSON(address, await sessionCipher.encrypt(paddedMessage));
                }));
            } catch(e) {
                if (e instanceof libsignal.UntrustedIdentityKeyError) {
                    await this._handleIdentityKeyError(e, {forceThrow: !!attempts});
                } else {
                    this.emitError(addr, "Failed to create message", e);
                    return;
                }
            }
        } while(!messages &amp;&amp; !attempts++);
        try {
            await this.transmitMessage(addr, messages, this.timestamp);
        } catch(e) {
            if (e instanceof errors.ProtocolError &amp;&amp; (e.code === 410 || e.code === 409)) {
                if (!recurse) {
                    this.emitError(addr, "Hit retry limit attempting to reload device list", e);
                    return;
                }
                if (e.code === 409) {
                    await this.removeDeviceIdsForAddr(addr, e.response.extraDevices);
                } else {
                    await Promise.all(e.response.staleDevices.map(x => ciphers[x].closeOpenSession()));
                }
                const resetDevices = e.code === 410 ? e.response.staleDevices :
                                                      e.response.missingDevices;
                // Optimize first-contact key lookup (just get them all at once).
                const updateDevices = messages.length ? resetDevices : undefined;
                await this.getKeysForAddr(addr, updateDevices);
                await this._sendToAddr(addr, /*recurse*/ (e.code === 409));
            } else if (e.code === 401 || e.code === 403) {
                throw e;
            } else {
                this.emitError(addr, "Failed to send message", e);
                return;
            }
        }
        this.emitSent(addr);
    }

    async _sendToDevice(addr, deviceId, recurse) {
        const protoAddr = new libsignal.ProtocolAddress(addr, deviceId);
        const sessionCipher = new libsignal.SessionCipher(storage, protoAddr);
        if (!(await sessionCipher.hasOpenSession())) {
            await this.getKeysForAddr(addr, [deviceId]);
        }
        let encryptedMessage;
        let attempts = 0;
        do {
            try {
                encryptedMessage = await sessionCipher.encrypt(this.getPaddedMessageBuffer());
            } catch(e) {
                if (e instanceof libsignal.UntrustedIdentityKeyError) {
                    await this._handleIdentityKeyError(e, {forceThrow: !!attempts});
                } else {
                    this.emitError(addr, "Failed to create message", e);
                    return;
                }
            }
        } while(!encryptedMessage &amp;&amp; !attempts++);
        const messageBundle = this.toJSON(protoAddr, encryptedMessage, this.timestamp);
        try {
            await this.signal.sendMessage(addr, deviceId, messageBundle);
        } catch(e) {
            if (e instanceof errors.ProtocolError &amp;&amp; e.code === 410) {
                sessionCipher.closeOpenSession();  // Force getKeysForAddr on next call.
                await this._sendToDevice(addr, /*recurse*/ false);
            } else if (e.code === 401 || e.code === 403) {
                throw e;
            } else {
                this.emitError(addr, "Failed to send message", e);
                return;
            }
        }
        this.emitSent(addr);
    }

    toJSON(address, encryptedMsg, timestamp) {
        return {
            type: encryptedMsg.type,
            destinationDeviceId: address.deviceId,
            destinationRegistrationId: encryptedMsg.registrationId,
            content: encryptedMsg.body.toString('base64'),
            timestamp
        };
    }

    async initSessions(encodedAddr) {
        // Scan the address for devices that have closed sessions and fetch
        // new key material for said devices so we can encrypt messages for
        // them.
        const [addr, deviceId] = util.unencodeAddr(encodedAddr);
        const deviceIds = deviceId ? [deviceId] : await storage.getDeviceIds(addr);
        if (!deviceIds.length) {
            return;
        }
        const stale = (await Promise.all(deviceIds.map(async id => {
            const address = new libsignal.ProtocolAddress(addr, id);
            const sessionCipher = new libsignal.SessionCipher(storage, address);
            return !(await sessionCipher.hasOpenSession()) ? id : null;
        }))).filter(x => x !== null);
        if (stale.length === deviceIds.length) {
            await this.getKeysForAddr(addr);  // Get them all at once.
        } else if (stale.length) {
            await this.getKeysForAddr(addr, stale);
        }
    }

    async removeDeviceIdsForAddr(addr, deviceIdsToRemove) {
        if (!deviceIdsToRemove) {
            await storage.removeAllSessions(addr);
        } else {
            for (const id of deviceIdsToRemove) {
                const encodedAddr = addr + "." + id;
                await storage.removeSession(encodedAddr);
            }
        }
    }

    async sendToAddr(encodedAddr) {
        try {
            await this.initSessions(encodedAddr);
        } catch(e) {
            this.emitError(addr, "Failed to init sessions for: " + encodedAddr, e);
            throw e;
        }
        const [addr, deviceId] = util.unencodeAddr(encodedAddr);
        try {
            if (deviceId) {
                await this._sendToDevice(addr, deviceId, /*recurse*/ true);
            } else {
                await this._sendToAddr(addr, /*recurse*/ true);
            }
        } catch(e) {
            this.emitError(encodedAddr, "Failed to send to address " + encodedAddr, e);
            throw e;
        }
    }
}

module.exports = OutgoingMessage;
</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>

<link type="text/css" rel="stylesheet" href="../../css/jsdoc-overrides.css"/>
